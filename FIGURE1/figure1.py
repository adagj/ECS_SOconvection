#!/usr/bin/env python4
# -*- coding: utf-8 -*-
"""
YEAR: 2019 - 2021

@author: ADA GJERMUNDSEN

This script will reproduce FIGURE 1 in Gjermundsen et. al 2021
The data used for plotting is generated by scripts 
contained in the same folder as this (FIGURE1) 

"""

import xarray as xr
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import pearsonr
import random
from scipy.stats import linregress
from scipy.stats import theilslopes
import math
from scipy.stats.kde import gaussian_kde
import warnings
warnings.simplefilter('ignore')


def linearfit(ds):
    t = linregress(np.arange(0,ds.shape[0]),ds.values)
    val = t.slope*np.arange(0,ds.shape[0]) + t.intercept
    return val
  
def cmip_tos(modellist, path, nyears):
    print('\n Calculates TOS changes')
    tosvalues = {}
    tosglobal = {}
    var = 'tos'
    varglb = 'sst_glb'
    var = 'sst_35S'
    for model in modellist:
        try:
            dsa4xCO2 = xr.open_mfdataset(path + 'tos_areaavg_Omon_' + model + '_abrupt-4xCO2_r*_150_yravg.nc',decode_times=False)
            dsctrl = xr.open_mfdataset(path + 'tos_areaavg_Omon_' + model + '_piControl_r*_150_yravg.nc', decode_times=False)
            ds = dsa4xCO2[var].values - linearfit(dsctrl[var])
            ds = xr.DataArray(ds, dims=('year'), coords={'year':dsa4xCO2.year})
            ds = ds.isel(year = slice(-nyears, None)).mean(dim='year')
            dsglb = dsa4xCO2[varglb].values -  linearfit(dsctrl[varglb])
            dsglb = xr.DataArray(dsglb, dims=('year'), coords={'year':dsa4xCO2.year})
            dsglb = dsglb.isel(year = slice(-nyears, None)).mean(dim='year')
            if math.isnan(ds.values/dsglb.values):
                print('Model %s includes nan values'%model)
            else:
                tosvalues[model] = ds.values#/tos_glb.values
                tosglobal[model] = dsglb.values
        except:
            tosvalues[model] = None
            tosglobal[model] = None
    return tosvalues, tosglobal

def cmip_thetao(modellist, path , nyears):
    print('\n Calculates THETAO changes')
    thetaovalues = {}
    thetaoglobal={}
    varglb = 'ocntemp_glb'
    var = 'ocntemp_50S_1500m_bottom'
    for model in modellist:
        print(model)
        try:
            dsa4xCO2 = xr.open_mfdataset(path + 'thetao_volumeavg_Omon_' + model + '_abrupt-4xCO2_r*_150_yravg.nc',decode_times=False)
            dsctrl = xr.open_mfdataset(path + 'thetao_volumeavg_Omon_' + model + '_piControl_r*_150_yravg.nc',decode_times=False)
            ds = dsa4xCO2[var].values - linearfit(dsctrl[var])
            ds = xr.DataArray(ds, dims=('year'), coords={'year':dsa4xCO2.year})
            ds = ds.isel(year = slice(-nyears, None)).mean(dim='year')
            dsglb = dsa4xCO2[varglb].values -  linearfit(dsctrl[varglb])
            dsglb = xr.DataArray(dsglb, dims=('year'), coords={'year':dsa4xCO2.year})
            dsglb = dsglb.isel(year = slice(-nyears, None)).mean(dim='year')
            if math.isnan(ds.values/dsglb.values):
                print('Model %s includes nan values'%model)
            else:
                thetaovalues[model] =  ds.values/dsglb.values
                thetaoglobal[model] =  dsglb.values
        except:
            thetaovalues[model] =  None
            thetaoglobal[model] =  None
    return thetaovalues, thetaoglobal

def moc_change(modellist, path,  lat_lim):
    print('\n Calculates MOC changes')
    mocvalues = {}
    var = 'moc'  
    for model in modellist:
        try:
            dsa4xCO2 = xr.open_mfdataset(path + 'MOC_Omon_' + model +'_abrupt-4xCO2_*30yravg.nc',decode_times=False)
            dsctrl = xr.open_mfdataset(path + 'MOC_Omon_' + model +'_piControl_*_30yravg.nc',decode_times=False)
            if model in ['CNRM-CM5']:
                ds = 1e-3*dsa4xCO2[var]
                dsc = 1e-3*dsctrl[var]
            else:
                ds = 1e-9*dsa4xCO2[var]
                dsc = 1e-9*dsctrl[var]
            ds = ds.sel(lat=slice(-90,lat_lim))
            dsc = dsc.sel(lat=slice(-90,lat_lim))
            if model in ['CESM2','CESM2-WACCM','CESM2-FV2','CESM2-WACCM-FV2']:
                ds = ds.assign_coords({'lev': ds.lev/1e2})
                dsc = dsc.assign_coords({'lev': dsc.lev/1e2})
            if model in ['inmcm4']:
                ds = ds.assign_coords({'lev': -ds.lev})
                dsc = dsc.assign_coords({'lev': -dsc.lev})
            ds = ds.sel(lev=slice(2000,None)) 
            dsc = dsc.sel(lev=slice(2000,None))
            ds = ds.min(dim='lev').squeeze() # per latitude
            weights = xr.ufuncs.cos(xr.ufuncs.deg2rad(ds.lat))*ds.notnull()
            ds = (ds*weights).sum(dim='lat')/weights.sum()
            dsc = dsc.min(dim='lev').squeeze() # per latitude
            weights = xr.ufuncs.cos(xr.ufuncs.deg2rad(dsc.lat))*dsc.notnull()
            dsc = (dsc*weights).sum(dim='lat')/weights.sum()
            mocvalues[model]= ds.values - dsc.values
        except:
            mocvalues[model]=None
    return mocvalues

def kernel_swcf(modellist, var, path):
    swcf={}
    for model in modellist:
        try:
            ds = xr.open_dataset(path + model+'_kernel_feedbacks.nc')
            if not np.isfinite(ds[var]):
                swcf[model]=None
            else:
                swcf[model]=np.float(ds[var].values)
        except:
            swcf[model]=None
    return swcf
      
def make_robust_r(x, y, k, N):
    tmp = []
    r=[]
    for expid, ecs in y.items():
        if expid not in x:
            print(expid)
            continue
        if x[expid] and y[expid] :
            tmp.append([x[expid], np.float(y[expid])])
    for i in range(0,N):
            samp = random.sample(tmp,k)
            x = np.array(samp).T[0]
            y = np.array(samp).T[1]
            corr, pv = pearsonr(x,y)
            r.append((corr,pv))
    return r

def plot_correlation_dots(ax, x, y, cmip,  color, xy, xy1=None):
    if cmip == 6:
        ecsvalues = np.load('path_to_data/' + 'ecs_cmip6_150yrs.npy', allow_pickle='TRUE').item()
    if cmip == 5:
        ecsvalues = np.load('path_to_data/' + 'ecs_cmip5_150yrs.npy', allow_pickle='TRUE').item()
    vary=[]
    varx=[]
    models=[]
    n=0
    for expid in {k: v for k, v in sorted(ecsvalues.items(), key=lambda item: item[1])}:
        if expid not in x:
            continue
        elif expid not in y:
            continue
        else:
            n=n+1
        if x[expid] and y[expid]:
            models.append(expid)
            vary.append(np.float(y[expid]))
            varx.append(np.float(x[expid]))
            if expid in ['NorESM2-LM', 'CESM2']:
                ax.annotate(str(n), xy=(np.float(x[expid]),np.float(y[expid])), color='maroon', fontsize = 9, fontweight='bold', zorder = 300)
            else:
                ax.annotate(str(n), xy=(np.float(x[expid]),np.float(y[expid])), color=color, fontsize = 8, fontweight='bold', zorder = 0)
           
    xm=np.array(varx)
    ym=np.array(vary)
    ms,mi,hs,ls = theilslopes(ym,xm)
    linfit = mi + ms*xm
    ax.plot(xm,linfit, color = color,linewidth=.5)
    
    N=50000
    nmodels = 10
    rvals, pvals, kdes, dss = calculate_pdfs(N, nmodels, x,y)
    ax.annotate('r² = %.2f, p = %.3f'%(np.round(np.mean(rvals**2),2), np.mean(pvals)), xy=xy, color=color, fontsize = 9)        

    if xy1:
        # In addition, calculate regression when two outlier CMIP6 models 'GISS-E2-1-H', 'INM-CM4-8' are excluded
        vary=[]
        varx=[]
        x1 = {key:val for key, val in x.items() if key not in ['GISS-E2-1-H', 'INM-CM4-8']}
        y1 = {key:val for key, val in y.items() if key not in ['GISS-E2-1-H', 'INM-CM4-8']}
        for expid in {k: v for k, v in sorted(ecsvalues.items(), key=lambda item: item[1])}:
            if expid not in x1:
                continue
            elif expid not in y1:
                continue
            else:
                n=n+1
            if x1[expid] and y1[expid] :
                vary.append(np.float(y1[expid]))
                varx.append(np.float(x1[expid]))
        xm1=np.array(varx)
        ym1=np.array(vary)
        ms,mi,hs,ls = theilslopes(ym1,xm1)
        linfit = mi + ms*xm1
        ax.plot(xm1,linfit, color = 'gray',zorder=0, linewidth = 1)
        rvals, pvals, kdes, dss = calculate_pdfs(N, nmodels, x1,y1)
        ax.annotate('r² = %.2f, p = %.3f'%(np.round(np.mean(rvals**2),2), np.mean(pvals)),  xy=xy1, color='gray', fontsize = 9)        
    for tick in ax.yaxis.get_major_ticks():
        tick.label.set_fontsize(10)  
    for tick in ax.xaxis.get_major_ticks():
        tick.label.set_fontsize(10)  
   
def calculate_pdfs(N, nmodels, x,y):
    rs = make_robust_r(x,y,nmodels,N)    
    rvals = np.array(rs).T[0]
    pvals = np.array(rs).T[1]
    kdes = gaussian_kde(rvals)
    dss = np.linspace(np.min(rvals), np.max(rvals))
    return rvals, pvals, kdes, dss

def handle_nan_values(l1, l2, alpha=0.05):
    l1n={}
    l2n={}
    for key, val in l1.items():
        if key not in l2:
            continue
        if np.isfinite(l1[key]) and np.isfinite(l2[key]):
            l1n[key] = l1[key]
            l2n[key] = l2[key]
    return l1n, l2n


if __name__ == '__main__':
    
    nyears = 30
    lat_lim=-35
    
    ### CMIP6 #######
    path = '/path_to_CMIP6_data/'
    ecs_cmip6 = np.load(path + 'ecs_cmip6_150yrs.npy', allow_pickle='TRUE').item()
    text_file = open(path +"cmip6_models.txt", "r")
    lines = text_file.readlines()
    modellist = [s.rstrip() for s in lines]
    x6, xg6 = cmip_thetao(modellist, path + 'volumeavg/',  nyears)
    x6sst, xg6sst  = cmip_tos(modellist, path + 'areaavg/', nyears)
    dx6moc = moc_change(modellist, path + 'mocs/', lat_lim=lat_lim)
    x6swcf_kp= kernel_swcf(modellist, 'sw_cf_35S', path + 'feedbacks/')
   
    # ### CMIP5 #######
    path = 'path_to_CMIP5_data/'
    ecs_cmip5 = np.load( path + 'ecs_cmip5_150yrs.npy', allow_pickle='TRUE').item()
    text_file = open(path +"cmip5_models.txt", "r")
    lines = text_file.readlines()
    modellist = [s.rstrip() for s in lines]
    x5, xg5 = cmip_thetao(modellist, path + 'volumeavg/',  nyears)
    x5sst, xg5sst  = cmip_tos(modellist, path + 'areaavg/', nyears)
    dx5moc = moc_change(modellist, path + 'mocs/', lat_lim=lat_lim)
    x5swcf_kp= kernel_swcf(modellist, 'sw_cf_35S', path + 'feedbacks/')

    ### Method used for calculating correlation r^2 and p-value
    # The Pearson correlation coefficient r$^2$ and the p values 
    # are calculated using a Monte-Carlo sampling of 50.000 subsamples of 10 models and then averaged.
    
    
#%%
    mm = .1/2.54  # millimeters in inches
    fig =  plt.figure(figsize=(180*mm, 185*mm))
    gs = fig.add_gridspec(2,2)
    ax = fig.add_subplot(gs[0,0])
    ax.set_title(label="a)", loc="left", fontsize=10, fontweight='bold') 
    plot_correlation_dots(ax, x5swcf_kp, ecs_cmip5, cmip=5, color = 'tab:blue', xy = (-1.52,5.5))
    plot_correlation_dots(ax, x6swcf_kp, ecs_cmip6, cmip=6, color = 'tab:orange', xy=(-1.52, 5.8))#, xy1 = (-0.4,5.5))
    ax.set_xlabel('SO SW cloud feedback ' + r"[W m$^{-2}$ K$^{-1}$]", fontsize=9)
    ax.set_ylabel('EffCS value [K]', fontsize=9)
    ax.set_ylim(1.5,6.2)
    ax.set_xlim(-1.55,1.)
    
    
    ax = fig.add_subplot(gs[0,1])
    ax.set_title(label="b)", loc="left", fontsize=10, fontweight='bold') 
    plot_correlation_dots(ax, x5sst, x5swcf_kp, cmip=5, color = 'tab:blue', xy = (1.6, .85))
    plot_correlation_dots(ax, x6sst, x6swcf_kp, cmip=6, color = 'tab:orange', xy=(1.6, 1))#, xy1 = (1.6,.6))
    ax.set_xlabel('SO SST change [K]', fontsize=9)
    ax.set_ylabel('SO SW cloud feedback ' + r"[W m$^{-2}$ K$^{-1}$]", fontsize=9)
    ax.set_xlim(1.5,7)
    ax.set_ylim(-1.5,1.25)
 
    ax = fig.add_subplot(gs[1,0])
    ax.set_title(label="c)", loc="left", fontsize=12, fontweight='bold') 
    plot_correlation_dots(ax, x5, x5sst, cmip=5, color = 'tab:blue', xy = (.7,5.8))
    plot_correlation_dots(ax, x6, x6sst, cmip=6, color = 'tab:orange', xy = (.7,6.5), xy1 = (.7,6.15))
    ax.set_xlabel('SO '+ r"$\Delta$T"+ ' below 1500m / Global '+r"$\Delta$T", fontsize=9)
    ax.set_ylabel('SO SST change [K]', fontsize=9)
    ax.set_ylim(1,7)
    ax.set_xlim(0.0,1.3)
   
    ax = fig.add_subplot(gs[1,1])
    ax.set_title(label="d)", loc="left", fontsize=12, fontweight='bold') 
    plot_correlation_dots(ax, dx5moc, x5, cmip=5, color = 'tab:blue', xy = (.1,1.03))
    plot_correlation_dots(ax, dx6moc, x6, cmip=6, color = 'tab:orange', xy = (.1,1.1))#, xy1 = (1.7,1.03))
    ax.set_xlabel('Deep SMOC reduction [Sv]', fontsize=9)
    ax.set_ylabel('SO '+ r"$\Delta$T"+ ' below 1500m / Global '+r"$\Delta$T", fontsize=9)
    ax.set_xlim(-0.1,8.7)
    ax.set_ylim(0.0,1.2)
    
    plt.subplots_adjust(left=0.07, bottom=0.08, right=0.98, top=.96, wspace = .27, hspace = .28)
    plt.savefig('path_to_save_figures_folder/' + 'FIGURE1.pdf')
